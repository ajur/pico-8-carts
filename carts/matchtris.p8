pico-8 cartridge // http://www.pico-8.com
version 16
__lua__
-- matchtris v0.2
-- columns clone by ajur

-- the idea was to recreate game from old 'bricks games' handhelds
-- and now i know it's based on popular consoles game series ^^

-- settings tab

cols = 7
rows = 14
offset_top = 1
offset_left = 2

fall_delay = 30
clear_time = 15

blocks_types_count = 5
use_coloured_blocks = true
monochrome_spr_idx = 2
coloured_spr_idx = 18
-->8
-- game states tab

state = nil

function run_state(self, with_update)
	state = self
	if state.init then state:init() end
	if with_update and state.update then state:update() end
end

states = {
	init = {run = run_state},
	new_block = {run = run_state},
	move = {run = run_state},
	clear = {run = run_state},
	fall = {run = run_state},
	over = {run = run_state}
}

-- state init

function states.init:init()
	printh("+++ init init state")
	board:clear()
	states.new_block:run()
end

-- state new_block

function states.new_block:init()
	printh("+++ init new_block state")
	local still_paying = block:new()

	if not still_paying then
		states.over:run()
	else
		states.move:run()
	end
end

-- state move

function states.move:init()
	printh("+++ init move state")
	self.fall_delay_timer = fall_delay
end

function states.move:update()
	self.fall_delay_timer -= 1

	if self.fall_delay_timer == 0 then
		self.fall_delay_timer = fall_delay

		local falled = block:move_down()
		if not falled then
			block:place()
			states.clear:run()
			return
		end
	end

	if btnp(0) then
		block:move_left()
	elseif btnp(1) then
		block:move_right()
	elseif btnp(2) then
		block:rotate()
	elseif btnp(3) then
		self.fall_delay_timer = 1
	end
end

function states.move:draw()
	cls()
	map(0,0,0,0)
	board:draw()
	block:draw()
end

-- state clear

function states.clear:init()
	printh("+++ init clear state")
	self.winning = board:get_winning()

	if not self.winning then
		states.new_block:run()
	else
		self.timer = clear_time
		self.blocks = self:extract_blocks()
	end
end

function states.clear:extract_blocks()
	local blocks = {}
	for line in all(self.winning) do
		for block in all(line) do
			local s = board:get(block[1], block[2])
			if s != 0 then
				add(blocks, {
					sprite = s,
					row = block[1],
					col = block[2]
				})
				board:set(block[1], block[2], 0)
			end
		end
	end
	return blocks
end

function states.clear:update()
	self.timer -= 1

	if self.timer <= 0 then
		states.fall:run()
	end
end

function states.clear:draw()
	cls()
	map(0,0,0,0)
	board:draw()

	for c = 8,12 do
		pal(c,7)
	end

	for b in all(self.blocks) do
		local x = (b.col + offset_left) * 8
		local y = (b.row + offset_top) * 8
		spr(b.sprite,x,y)
	end
	pal()
end

-- state fall

function states.fall:init()
	printh("+++ init fall state")
end

function states.fall:update()
	local has_fallen = board:fall_hanging()
	if has_fallen then
		states.clear:run()
	else
		states.new_block:run()
	end
end

function states.fall:draw()
	cls()
	map(0,0,0,0)
	board:draw()
end

-- state over

function states.over:draw()
	cls()
	map(0,0,0,0)
	board:draw()
	for c = 8,12 do
		pal(c,14)
	end
	block:draw(true)
	pal()
	print("game over", 80, 64, 14)
end

-->8
-- board tab

board = {}

function board:clear()
	for col=0,cols-1 do
		for row=0,rows-1 do
			self[col + row * cols] = 0
		end
	end
end

function board:contains(row, col)
	return row >= 0 and row < rows and col >= 0 and col < cols
end

function board:get(row, col)
	if self:contains(row, col) then
		return self[col + row * cols]
	end
	return nil
end

function board:set(row, col, val)
	if self:contains(row, col) then
		self[col + row * cols] = val
		self.last_mod_row = row
		self.last_mod_col = col
	end
end

function board:draw()
	for col=0,cols-1 do
		for row=0,rows-1 do
			local s = self[col + row * cols]
			local x = (col + offset_left) * 8
			local y = (row + offset_top) * 8
			spr(s, x, y)
		end
	end
end

function board:can_set_at(row, col)
	return self:contains(row, col) and self:get(row, col) == 0
end

function board:_flood(row, col, dr, dc, line)
	local nrow = row + dr
	local ncol = col + dc
	if self:get(row, col) == self:get(nrow, ncol) then
		add(line, {nrow, ncol})
		self:_flood(nrow, ncol, dr, dc, line)
	end
end

board._dirs = {
	{-1, 0},
	{0, -1},
	{-1, -1},
	{-1, 1}
}

function board:get_winning()
	local lines = {}
	for col=0,cols-1 do
		for row=0,rows-1 do
			if self:get(row,col) > 0 then
				for dir in all(self._dirs) do
					local line = {{row, col}}
					self:_flood(row, col, dir[1], dir[2], line)
					self:_flood(row, col, -dir[1], -dir[2], line)
					if #line > 2 then
						add(lines, line)
					end
				end
			end
		end
	end
	if #lines > 0 then return lines else return nil end
end

function board:fall_hanging()
	local is_falling = false
	for col=0,cols-1 do
		local empty = nil
		for row=rows-1,0,-1 do
			local cell = self:get(row, col)
			if not empty and cell == 0 then
				empty = row
			end
			if cell > 0 then
				if empty then
					self:set(empty, col, cell)
					self:set(row, col, 0)
					empty -= 1
					is_falling = true
				end
			end
		end
	end
	return is_falling
end

-->8
-- blocks tab

function random_block()
	return flr(rnd(blocks_types_count)) + (use_coloured_blocks and coloured_spr_idx or monochrome_spr_idx)
end

block = {}

function block:new()
	if not self.next then
		self.next = {random_block(), random_block(), random_block()}
	end

	for i=1,3 do
		self[i] = {
			sprite = self.next[i],
			col = 3,
			row = i-3
		}
		self.next[i] = random_block()
	end

	return board:can_set_at(self[3].row, self[3].col)
end

function block:place()
	for i=1,3 do
		board:set(self[i].row, self[i].col, self[i].sprite)
	end
end

function block:move_down()
	if board:can_set_at(self[3].row + 1, self[3].col) then
		for i=1,3 do self[i].row += 1 end
		return true
	end
	return false
end

function block:move_left()
	if board:can_set_at(self[3].row, self[3].col - 1) then
		for i=1,3 do self[i].col -= 1 end
		return true
	end
	return false
end

function block:move_right()
	if board:can_set_at(self[3].row, self[3].col + 1) then
		for i=1,3 do self[i].col += 1 end
		return true
	end
	return false
end

function block:rotate()
	self[1].sprite, self[2].sprite, self[3].sprite =
		self[2].sprite, self[3].sprite, self[1].sprite
end

function block:draw(without_next)
	for i=1,3 do
		if self[i].row >= 0 then
			local x = (self[i].col + offset_left) * 8
			local y = (self[i].row + offset_top) * 8
			spr(self[i].sprite, x, y)
		end
	end

	if self.next and not without_next then
		for i=1,3 do
			local x = 12 * 8
			local y = (i + 2) * 8
			spr(self.next[i], x, y)
		end
	end
end

-->8
-- pico loop functions tab

function _init()
	states.init:run()
end

function _update()
	if state.update then state:update() end
end

function _draw()
	if state.draw then state:draw() end
end

__gfx__
00000000111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000010000000000ccc00000ccc0000ccccc000ccccc000ccccc0000000000000000000000000000000000000000000000000000000000000000000000000
000000001000000000c000c000c000c00c00000c0c00000c0c00000c000000000000000220020202220000000000000000000000000000000000000000000000
00000000100000000c00000c0c00c00c0c00000c0c0ccc0c0c00000c000000000000000202002000200000000000000000000000000000000000000000000000
00000000100000000c00000c0c0ccc0c0c00000c0c0c0c0c0c00c00c000000000000000202020200200000000000000000000000000000000000000000000000
00000000100000000c00000c0c00c00c0c00000c0c0ccc0c0c00000c000000000000000000000000000000000000000000000000000000000000000000000000
000000001000000000c000c000c000c00c00000c0c00000c0c00000c000000000000002222222222222000000000000000000000000000000000000000000000
0000000000000000000ccc00000ccc0000ccccc000ccccc000ccccc0000000000000002000000000002000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000002000000000002000000000000000000000000000000000000000000000
0000000000000000000ccc000009990000aaaaa000bbbbb000888880000000000000002000000000002000000000000000000000000000000000000000000000
000000000000000000c000c0009000900a00000a0b00000b08000008000000000000002000000000002000000000000000000000000000000000000000000000
00000000000000000c00000c090090090a00000a0b0bbb0b08000008000000000000002000000000002000000000000000000000000000000000000000000000
00000000000000000c00000c090999090a00000a0b0b0b0b08008008000000000000002000000000002000000000000000000000000000000000000000000000
00000000000000000c00000c090090090a00000a0b0bbb0b08000008000000000000002000000000002000000000000000000000000000000000000000000000
000000000000000000c000c0009000900a00000a0b00000b08000008000000000000002000000000002000000000000000000000000000000000000000000000
0000000000000000000ccc000009990000aaaaa000bbbbb000888880000000000000002000000000002000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000002000000000002000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000002000000000002000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000002222222222222000000000000000000000000000000000000000000000
__map__
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000001010101010101000008090a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000001010101010101000018191a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000001010101010101000018191a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000001010101010101000018191a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000001010101010101000028292a000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000010101010101010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
